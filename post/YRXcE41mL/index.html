<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>JS学习日记【11】收尾：异步通信 Storage/FetchAPI/Promise/Web worker - 小马的世界</title>
<link rel="shortcut icon" href="https://ma.shanpeng.im/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://ma.shanpeng.im/media/css/tailwind.css">
<link rel="stylesheet" href="https://ma.shanpeng.im/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JS学习日记【11】收尾：异步通信 Storage/FetchAPI/Promise/Web worker - 小马的世界 - Atom Feed" href="https://ma.shanpeng.im/atom.xml">


  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0N4K7FPFJJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-0N4K7FPFJJ');
  </script>
    

  <meta name="description" content="Storage 对象
Storage 对象是 JavaScript 中用于存储数据的一个重要工具。它有两种形式：localStorage 和 sessionStorage。下面通过一个具体的例子来解释这两种形式。
localStorage
..." />
  <meta property="og:title" content="JS学习日记【11】收尾：异步通信 Storage/FetchAPI/Promise/Web worker - 小马的世界">
  <meta property="og:description" content="Storage 对象
Storage 对象是 JavaScript 中用于存储数据的一个重要工具。它有两种形式：localStorage 和 sessionStorage。下面通过一个具体的例子来解释这两种形式。
localStorage
..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://ma.shanpeng.im/post/YRXcE41mL/" />
  <meta property="og:image" content="https://ma.shanpeng.im/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="JS学习日记【11】收尾：异步通信 Storage/FetchAPI/Promise/Web worker - 小马的世界">
  <meta name="twitter:description" content="Storage 对象
Storage 对象是 JavaScript 中用于存储数据的一个重要工具。它有两种形式：localStorage 和 sessionStorage。下面通过一个具体的例子来解释这两种形式。
localStorage
...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://ma.shanpeng.im/post/YRXcE41mL/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://ma.shanpeng.im/media/css/prism-atom-dark.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://ma.shanpeng.im" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      小马的世界
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          JS学习日记【11】收尾：异步通信 Storage/FetchAPI/Promise/Web worker
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2023-11-17 · 10 min read</div>
          
            <a href="https://ma.shanpeng.im/tag/javascript/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              JavaScript
            </a>
          
            <a href="https://ma.shanpeng.im/tag/YqjZAfzGz/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              中文Chinese中国語
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <h1 id="storage-对象">Storage 对象</h1>
<p><code>Storage</code> 对象是 JavaScript 中用于存储数据的一个重要工具。它有两种形式：<code>localStorage</code> 和 <code>sessionStorage</code>。下面通过一个具体的例子来解释这两种形式。</p>
<h2 id="localstorage">localStorage</h2>
<ul>
<li><strong>描述</strong>: <code>localStorage</code> 用于长期存储数据，直到手动清除。</li>
<li><strong>生命周期</strong>: 在多个浏览器会话之间持久。</li>
<li><strong>存储限制</strong>: 通常为 5MB。</li>
</ul>
<h3 id="示例">示例</h3>
<p>假设我们要在用户的浏览器中保存他们的用户名。</p>
<pre><code class="language-javascript">// 保存用户名
localStorage.setItem('username', 'user123');

// 获取用户名
let username = localStorage.getItem('username');
console.log(username); // 输出: user123

// 移除用户名
localStorage.removeItem('username');
</code></pre>
<h2 id="sessionstorage">sessionStorage</h2>
<ul>
<li><strong>描述</strong>: <code>sessionStorage</code> 用于临时存储数据，在浏览器窗口或标签页关闭时清除。</li>
<li><strong>生命周期</strong>: 仅在当前浏览器窗口或标签页中有效。</li>
<li><strong>存储限制</strong>: 通常也为 5MB。</li>
</ul>
<h3 id="示例-2">示例</h3>
<p>假设我们要在用户浏览某个页面时临时存储一个会话ID。</p>
<pre><code class="language-javascript">// 保存会话ID
sessionStorage.setItem('sessionId', 'abc123');

// 获取会话ID
let sessionId = sessionStorage.getItem('sessionId');
console.log(sessionId); // 输出: abc123

// 移除会话ID
sessionStorage.removeItem('sessionId');
</code></pre>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>对于敏感数据，不建议使用 <code>localStorage</code> 或 <code>sessionStorage</code>，因为它们在客户端存储，可能存在安全风险。</li>
<li>存储的数据都是字符串类型，如果需要存储对象，可以使用 <code>JSON.stringify</code> 来转换对象为字符串，获取时再用 <code>JSON.parse</code> 还原。</li>
</ul>
<h2 id="异步通信和-fetch-api">异步通信和 Fetch API</h2>
<p>异步通信是 Web 开发中的一个重要概念，它允许 Web 应用在不干扰用户界面的情况下与服务器进行数据交换。Fetch API 是实现异步通信的现代方法之一。</p>
<h3 id="什么是异步通信asynchronous-communication">什么是异步通信（Asynchronous Communication）</h3>
<p>在理解异步通信之前，我们先来看一下同步通信。</p>
<ul>
<li>
<p><strong>同步通信</strong>: 在同步操作中，任务按顺序执行，每个任务的完成是下一个任务开始的前提。这意味着如果某个任务耗时较长，后续的任务都必须等待。</p>
</li>
<li>
<p><strong>异步通信</strong>: 异步操作允许在等待耗时任务（例如网络请求）的同时继续执行其他任务。这意味着应用可以在没有明显延迟的情况下响应用户交互，同时进行数据加载等操作。</p>
</li>
</ul>
<h3 id="fetch-api">Fetch API</h3>
<p>Fetch API 提供了一个强大且灵活的方法来发出异步 HTTP 请求。它是 XMLHttpRequest 的现代替代品，提供了更简洁、更强大的功能。</p>
<h4 id="基本使用">基本使用</h4>
<p>以下是 Fetch API 的一个基本示例：</p>
<pre><code class="language-javascript">fetch('https://api.example.com/data')
  .then(response =&gt; {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json(); // 解析 JSON 数据
  })
  .then(data =&gt; {
    console.log(data); // 处理数据
  })
  .catch(error =&gt; {
    console.error('There has been a problem with your fetch operation:', error);
  });
</code></pre>
<p>在这个示例中：</p>
<ol>
<li><code>fetch</code> 函数调用一个 URL（在这个例子中是 <code>'https://api.example.com/data'</code>）。</li>
<li>返回一个 <code>Promise</code>，它是异步操作的一种表示方式。</li>
<li>使用 <code>.then()</code> 方法来定义当 <code>Promise</code> 完成时应该发生的事情。第一个 <code>.then()</code> 调用是用来检查响应并解析 JSON 数据。</li>
<li>第二个 <code>.then()</code> 调用处理解析后的数据。</li>
<li><code>.catch()</code> 方法用于捕获任何在请求过程中发生的错误。</li>
</ol>
<h4 id="高级特性">高级特性</h4>
<ul>
<li><strong>发送 POST 请求</strong>:</li>
</ul>
<pre><code class="language-javascript">  fetch('https://api.example.com/data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ key: 'value' }) // 发送 JSON 数据
  });
</code></pre>
<ul>
<li><strong>异步/等待（Async/Await）</strong>: 这是一种更现代的处理异步操作的方式。</li>
</ul>
<pre><code class="language-javascript">  async function fetchData() {
    try {
      const response = await fetch('https://api.example.com/data');
      const data = await response.json();
      console.log(data);
    } catch (error) {
      console.error('Error:', error);
    }
  }

  fetchData();
</code></pre>
<h3 id="总结">总结</h3>
<p>异步通信允许 Web 应用在后台执行耗时任务（如数据请求），同时不阻塞用户界面。Fetch API 是实现这种通信的强大工具，它通过 Promise 提供了一种优雅的方式来处理异步 HTTP 请求。通过 Fetch API，开发者可以轻松实现数据的加载、提交等操作，提高应用的性能和用户体验。</p>
<h2 id="promise-对象">Promise 对象</h2>
<p><code>Promise</code> 对象是 JavaScript 中处理异步操作的关键概念。在深入了解 <code>Promise</code> 之前，我们需要理解异步编程在 JavaScript 中的重要性。</p>
<h3 id="异步编程">异步编程</h3>
<p>JavaScript 是一种单线程语言，意味着它一次只能执行一个任务。为了不阻塞代码执行（例如等待网络请求、读取文件等耗时操作），JavaScript 使用异步编程模式。这就是 <code>Promise</code> 发挥作用的地方。</p>
<h3 id="什么是-promise">什么是 Promise</h3>
<p><code>Promise</code> 是一个表示未来将会完成的操作的对象。它可以处于以下三种状态之一：</p>
<ol>
<li><strong>Pending（进行中）</strong>: 初始状态，既不是成功，也不是失败状态。</li>
<li><strong>Fulfilled（已成功）</strong>: 操作成功完成。</li>
<li><strong>Rejected（已失败）</strong>: 操作失败。</li>
</ol>
<p><code>Promise</code> 提供了一种优雅的方式来处理异步操作的成功或失败，允许你编写更简洁、易于理解的代码，特别是在处理多个异步操作时。</p>
<h3 id="创建一个-promise">创建一个 Promise</h3>
<p><code>Promise</code> 是通过 <code>new Promise()</code> 构造函数创建的，它接受一个函数作为参数，该函数有两个参数：<code>resolve</code> 和 <code>reject</code>。这两个参数也是函数，用于改变 <code>Promise</code> 的状态。</p>
<pre><code class="language-javascript">let promise = new Promise(function(resolve, reject) {
  // 异步操作的代码...

  if (/* 操作成功 */) {
    resolve(value); // 将 Promise 的状态改为 Fulfilled
  } else {
    reject(error); // 将 Promise 的状态改为 Rejected
  }
});
</code></pre>
<h3 id="使用-promise">使用 Promise</h3>
<p>一旦 <code>Promise</code> 被创建，你可以使用 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 方法来处理成功、失败和完成（无论成功或失败）的情况。</p>
<ul>
<li><code>.then()</code> 接受两个函数作为参数，第一个处理成功的情况，第二个（可选的）处理失败的情况。</li>
<li><code>.catch()</code> 用于捕获失败的情况。</li>
<li><code>.finally()</code> 是无论成功还是失败都会执行的。</li>
</ul>
<pre><code class="language-javascript">promise
  .then(
    result =&gt; { /* 处理成功的结果 */ },
    error =&gt; { /* 处理错误 */ }
  )
  .catch(error =&gt; { /* 只处理错误 */ })
  .finally(() =&gt; { /* 总是会执行的代码 */ });
</code></pre>
<h3 id="链式调用">链式调用</h3>
<p><code>Promise</code> 的一个强大特性是支持链式调用。你可以在一个 <code>Promise</code> 的 <code>.then()</code> 方法中返回另一个 <code>Promise</code>，然后继续使用 <code>.then()</code> 处理后续操作。</p>
<pre><code class="language-javascript">fetch('https://api.example.com/data') // Fetch 返回一个 Promise
  .then(response =&gt; response.json()) // 第一个 .then 返回一个新的 Promise
  .then(data =&gt; { /* 处理数据 */ })
  .catch(error =&gt; { /* 处理错误 */ });
</code></pre>
<h3 id="promiseall">Promise.all</h3>
<p>当你需要同时处理多个 <code>Promise</code> 并等待它们全部完成时，可以使用 <code>Promise.all</code>。这个方法接收一个 <code>Promise</code> 数组，并返回一个新的 <code>Promise</code>。</p>
<pre><code class="language-javascript">Promise.all([promise1, promise2, promise3])
  .then(results =&gt; {
    // 当所有 promises 都完成时执行
    // results 是一个数组，包含每个 promise 的结果
  })
  .catch(error =&gt; {
    // 如果任何一个 promise 失败
  });
</code></pre>
<h3 id="总结-2">总结</h3>
<p><code>Promise</code> 是 JavaScript 中处理异步操作的强大工具。它提供了一种清晰的方式来处理异步操作的成功或失败，并支持链式调用和组合多个异步操作。这使得编写异步代码变得更加简洁和易于管理。</p>
<h2 id="web-workers">Web Workers</h2>
<p>当然可以。Web Workers 是一个强大的 Web API，它允许在 JavaScript 的主执行线程之外运行脚本，实现真正的多线程编程。由于 JavaScript 通常是单线程的，长时间运行的或复杂的计算任务可能会阻塞用户界面。Web Workers 通过允许这些任务在后台线程中运行来解决这个问题。</p>
<h3 id="基本概念">基本概念</h3>
<ul>
<li><strong>多线程</strong>: Web Workers 允许你在单独的线程中运行代码，这意味着你可以执行长时间运行的任务，而不会阻塞浏览器的主线程。</li>
<li><strong>独立运行</strong>: Worker 线程和主线程完全独立，它们不共享作用域或任何全局数据。这意味着它们不能直接访问 DOM 或其他主线程特有的对象。</li>
</ul>
<h3 id="创建和使用-web-worker">创建和使用 Web Worker</h3>
<ol>
<li><strong>创建 Worker 文件</strong>: 首先，需要创建一个 JavaScript 文件，其中包含将在 Worker 线程中执行的代码。</li>
</ol>
<pre><code class="language-javascript">   // worker.js
   self.addEventListener('message', function(e) {
     var data = e.data;
     // 执行一些操作...
     var result = processData(data);
     self.postMessage(result);
   });
</code></pre>
<ol>
<li><strong>实例化 Worker</strong>: 在主 JavaScript 文件中，你可以创建一个 Worker 实例，并指向上述 JavaScript 文件。</li>
</ol>
<pre><code class="language-javascript">   // 主线程
   var myWorker = new Worker('worker.js');

   myWorker.postMessage(data); // 发送数据到 Worker

   myWorker.addEventListener('message', function(e) {
     var result = e.data;
     // 使用 Worker 计算的结果
   });
</code></pre>
<h3 id="通信">通信</h3>
<ul>
<li><strong>主线程与 Worker 通信</strong>: 使用 <code>postMessage()</code> 方法发送消息，使用 <code>onmessage</code> 或 <code>addEventListener</code> 监听消息。</li>
<li><strong>数据传输</strong>: 数据是通过结构化克隆算法复制的，这意味着发送给 Worker 的对象是其副本，而不是原始对象。</li>
</ul>
<h3 id="限制和注意事项">限制和注意事项</h3>
<ul>
<li><strong>无 DOM 访问</strong>: Workers 无法访问 DOM。它们不能更新界面元素。</li>
<li><strong>限制的全局对象</strong>: Workers 只能访问部分全局对象和函数，如 <code>navigator</code> 或 <code>setTimeout</code>。</li>
<li><strong>内存和性能考虑</strong>: 虽然 Workers 可以提高性能，但过多的 Workers 可能会增加内存使用并降低性能。</li>
</ul>
<h3 id="应用场景">应用场景</h3>
<p>Web Workers 特别适用于那些需要执行密集型计算或长时间运行的任务的应用，例如：</p>
<ul>
<li>大数据处理</li>
<li>图像或视频处理</li>
<li>复杂数学计算</li>
<li>后台数据处理或预取</li>
</ul>
<h3 id="总结-3">总结</h3>
<p>Web Workers 为 Web 应用提供了真正的多线程能力，允许在后台线程中执行 JavaScript，从而提高应用的响应性和性能。通过将复杂的计算任务从主线程中分离出来，Web Workers 确保主线程（负责 UI 和用户交互）保持流畅和响应。尽管有一些限制和考虑因素，但它们是现代 Web 应用中不可或缺的工具。</p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      
        

        
          <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script type="application/javascript" src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script type="application/javascript">

var options = {
  shortname: 'mas-world',
  apikey: 'YG8mZDStxobqmwNFwY04dJ1X16wMK2kaE7oQhDjcqkBo6eZlH8k86jABHHWnHGNO',
}
if ('https://disqus.com/api/') {
  options.api = 'https://disqus.com/api/'
}
var dsqjs = new DisqusJS(options)

</script>

        
      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
</footer>
<script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li><a href="#storage-%E5%AF%B9%E8%B1%A1">Storage 对象</a>
<ul>
<li><a href="#localstorage">localStorage</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#sessionstorage">sessionStorage</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B-2">示例</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%92%8C-fetch-api">异步通信和 Fetch API</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1asynchronous-communication">什么是异步通信（Asynchronous Communication）</a></li>
<li><a href="#fetch-api">Fetch API</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a></li>
<li><a href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">高级特性</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#promise-%E5%AF%B9%E8%B1%A1">Promise 对象</a>
<ul>
<li><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-promise">什么是 Promise</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-promise">创建一个 Promise</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-promise">使用 Promise</a></li>
<li><a href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">链式调用</a></li>
<li><a href="#promiseall">Promise.all</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
<li><a href="#web-workers">Web Workers</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-web-worker">创建和使用 Web Worker</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1">通信</a></li>
<li><a href="#%E9%99%90%E5%88%B6%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">限制和注意事项</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-3">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://ma.shanpeng.im/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://ma.shanpeng.im/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
  
    
  
</body>

</html>